data = read.csv("Puromycin.csv")

# Matriz de regresores
X = matrix(cbind(rep(1,12),data$Conc),12,2)
X

# Vector de los valores de respuesta observados
y <- matrix(data$Velocity)
y

# MÃ©todo de Gauss-Newton 

puromycin = function(Conc,theta1,theta2){
      Vel = theta1*Conc/(theta2+Conc)
      return(as.matrix(Vel))
}

#  Teta inicial = (205,0.08)^T
theta = matrix(c(205.0,0.08),2,1)
pred = round(puromycin(data$Conc,theta[1],theta[2]),2)
pred

# Tabla 2.1 de Bates & Watts (1988), p. 41
table = as.data.frame(cbind(rep(1:length(data$Conc)), X[,2], y, pred))
names(table) = c("Obs", "x", "y", "predicted_0")

# Calcular los residuos y agregarlos a la tabla
table$residual_0 = table$y - table$predicted

# Matriz derivada
derivative = function(Conc,theta1,theta2){
      d1 = round(Conc/(theta2+Conc),4)
      d2 = round(-theta1*Conc/(theta2+Conc)^2,2)
      return(as.matrix(cbind(d1,d2)))
}

# Calculating derivative matrix  (V^0) for all observations 
# and initial theta
V_0 = derivative(data$Conc,theta[1],theta[2])
V_0

table$der_theta1_0 = V_0[,1]
table$der_theta2_0 = V_0[,2]

# Calculating residual sum of squares for initial iteration
rss0 = sum(table$residual_0^2)

# QR decomposition of the derivative matrix V^0, with  
# the result given in a compact form
QR =qr(V_0)
QR$qr

# Reconstructing Q and R matrices from a QR object.
# In this case we obtain Q1 and R1
Q1 = qr.Q(QR)
Q1
R1 = qr.R(QR)
R1

# Checking that V_0=Q1*R1
V_0_alt = Q1%*%R1
V_0_alt


# Defining a residual vector from the corresponding column
# in table dataframe
z_0 = matrix(table$residual)

# Calculating w1=Q1^T*z_0
w1 = t(Q1)%*%z_0

# We know that R1*delta_0=w1. Then delta_0=inverse(R1)*w1
delta_0 = round(solve(R1)%*%w1,3)
delta_0

#  Updating theta = (213.03,0.063)^T
theta1 = theta + delta_0
table$predicted_1 = round(puromycin(data$Conc,theta1[1],theta1[2]),2)

# Calculating new residuals 
table$residual_1 = table$y - table$predicted_1

# Calculating residual sum of squares for new iteration
rss1 = sum(table$residual_1^2)

# rss1 (1205) is smaller than rss (3155). So we move to theta1
# and perform another iteration.
# The process is repeated until there is  change in the 
# residual sum of squares.
# Convergence is reached at theta = (212.7,0.0641)
theta_opt = matrix(c(212.7,0.0641),2,1)

# Optimal predicted values
table$predicted_opt = round(puromycin(data$Conc,theta_opt[1],theta_opt[2]),2)

# Calculating derivative matrix  (V^0) for all observations 
# and optimal theta
V_0_opt = derivative(data$Conc,theta_opt[1],theta_opt[2])
V_0_opt

table$der_theta1_opt = V_0_opt[,1]
table$der_theta2_opt = V_0_opt[,2]

# Calculating optimal residuals 
table$residual_opt = table$y - table$predicted_opt

# Calculating residual sum of squares for initial iteration
rss_opt = sum(table$residual_opt^2)

# QR decomposition of the derivative matrix V^0, with  
# the result given in a compact form
QR_opt =qr(V_0_opt)
QR_opt$qr

# Reconstructing Q and R matrices from a QR object.
# In this case we obtain Q1 and R1
Q1_opt = qr.Q(QR_opt)
Q1_opt
R1_opt = qr.R(QR_opt)
R1_opt

# Bands for the expected responses at Conc=0.4
y0.4 = round(puromycin(0.4,theta_opt[1],theta_opt[2]),1)
y0.4

# Derivative vector
v = derivative(0.4,theta_opt[1],theta_opt[2])
v

# v^T*inverse(R1)
vTinvR = v%*%solve(R1_opt)
vTinvR

# Norm  of the vector vTinvR
norm1 = sum(vTinvR*vTinvR)^0.5
norm1

# Plotting bands for  expected response
s = sqrt(rss_opt/10)
EFE = qf(0.95,2,10)
P = 2

xnew <- seq(0,1.2,0.01) #range
ynew = theta_opt[1]*xnew/(theta_opt[2] + xnew) 
quartz(width = 5.5, height = 7)
par(mfrow=c(1,1),mai=c(0.9,0.9,0.5,0.5),mgp=c(2.0,0.6,0),cex=1.2)
plot(data$Conc, data$Velocity, pch=20, col = "red", las =1,
     xlab = "Concentration (ppm)",
     ylab = expression(Velocity ~ (counts/min^2)),
     xlim = c(0,1.2),
     ylim = c(0,250))
lines(xnew,ynew,lwd=2)
lines(xnew,ynew+s*norm1*sqrt(P*EFE),lwd=2,lty=2,col="red")
lines(xnew,ynew-s*norm1*sqrt(P*EFE),lwd=2,lty=2,col="red")


